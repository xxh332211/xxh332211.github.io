<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>面向对象编程-prototype 对象 | xxh</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="目录
概述
构造函数的缺点
prototype属性的作用
原型链
constructor属性


instanceof运算符
Object.getPrototypeOf()
Object.setPrototypeOf()
Object.create()
Object.prototype.isPrototypeOf()
Object.prototype.proto
获取原型对象方法的比较大部分面向对">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象编程-prototype 对象">
<meta property="og:url" content="http://yoursite.com/2015/10/07/面向对象编程-prototype-对象/index.html">
<meta property="og:site_name" content="xxh">
<meta property="og:description" content="目录
概述
构造函数的缺点
prototype属性的作用
原型链
constructor属性


instanceof运算符
Object.getPrototypeOf()
Object.setPrototypeOf()
Object.create()
Object.prototype.isPrototypeOf()
Object.prototype.proto
获取原型对象方法的比较大部分面向对">
<meta property="og:updated_time" content="2017-03-06T10:44:46.836Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象编程-prototype 对象">
<meta name="twitter:description" content="目录
概述
构造函数的缺点
prototype属性的作用
原型链
constructor属性


instanceof运算符
Object.getPrototypeOf()
Object.setPrototypeOf()
Object.create()
Object.prototype.isPrototypeOf()
Object.prototype.proto
获取原型对象方法的比较大部分面向对">
  
    <link rel="alternate" href="/atom.xml" title="xxh" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xxh</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-面向对象编程-prototype-对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/07/面向对象编程-prototype-对象/" class="article-date">
  <time datetime="2015-10-07T10:30:38.000Z" itemprop="datePublished">2015-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面向对象编程-prototype 对象
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>概述<ul>
<li>构造函数的缺点</li>
<li>prototype属性的作用</li>
<li>原型链</li>
<li>constructor属性</li>
</ul>
</li>
<li>instanceof运算符</li>
<li>Object.getPrototypeOf()</li>
<li>Object.setPrototypeOf()</li>
<li>Object.create()</li>
<li>Object.prototype.isPrototypeOf()</li>
<li>Object.prototype.<strong>proto</strong></li>
<li>获取原型对象方法的比较<br>大部分面向对象的编程语言，都是以“类”（class）作为对象体系的语法基础。JavaScript语言不是如此，它的面向对象编程基于“原型对象”。</li>
</ul>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1构造函数的缺点"><a href="#1-1构造函数的缺点" class="headerlink" title="1.1构造函数的缺点"></a>1.1构造函数的缺点</h3><p>JavaScript通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Cat (name, color) &#123;</div><div class="line">  this.name = name;</div><div class="line">  this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var cat1 = new Cat(&apos;大毛&apos;, &apos;白色&apos;);</div><div class="line"></div><div class="line">cat1.name // &apos;大毛&apos;</div><div class="line">cat1.color // &apos;白色&apos;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面代码的Cat函数是一个构造函数，函数内部定义了name属性和color属性，所有实例对象都会生成这两个属性。但是，这样做是对系统资源的浪费，因为同一个构造函数的对象实例之间，无法共享属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Cat(name, color) &#123;</div><div class="line">  this.name = name;</div><div class="line">  this.color = color;</div><div class="line">  this.meow = function () &#123;</div><div class="line">    console.log(&apos;mew, mew, mew...&apos;);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var cat1 = new Cat(&apos;大毛&apos;, &apos;白色&apos;);</div><div class="line">var cat2 = new Cat(&apos;二毛&apos;, &apos;黑色&apos;);</div><div class="line"></div><div class="line">cat1.meow === cat2.meow</div><div class="line">// false</div></pre></td></tr></table></figure></p>
<p>上面代码中，cat1和cat2是同一个构造函数的实例。但是，它们的meow方法是不一样的，就是说每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。</p>
<h3 id="1-2prototype属性的作用"><a href="#1-2prototype属性的作用" class="headerlink" title="1.2prototype属性的作用"></a>1.2prototype属性的作用</h3><p>JavaScript的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象。</p>
<p>原型对象上的所有属性和方法，都能被派生对象共享。这就是JavaScript继承机制的基本设计。</p>
<p>通过构造函数生成实例对象时，会自动为实例对象分配原型对象。每一个构造函数都有一个prototype属性，这个属性就是实例对象的原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Animal (name) &#123;</div><div class="line">  this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Animal.prototype.color = &apos;white&apos;;</div><div class="line"></div><div class="line">var cat1 = new Animal(&apos;大毛&apos;);</div><div class="line">var cat2 = new Animal(&apos;二毛&apos;);</div><div class="line"></div><div class="line">cat1.color // &apos;white&apos;</div><div class="line">cat2.color // &apos;white&apos;</div></pre></td></tr></table></figure></p>
<p>上面代码中，构造函数Animal的prototype对象，就是实例对象cat1和cat2的原型对象。在原型对象上添加一个color属性。结果，实例对象都能读取该属性。</p>
<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Animal.prototype.color = &apos;yellow&apos;;</div><div class="line"></div><div class="line">cat1.color // &quot;yellow&quot;</div><div class="line">cat2.color // &quot;yellow&quot;</div></pre></td></tr></table></figure></p>
<p>上面代码中，原型对象的color属性的值变为yellow，两个实例对象的color属性立刻跟着变了。这是因为实例对象其实没有color属性，都是读取原型对象的color属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到构造函数的prototype属性指向的对象，去寻找该属性或方法。这就是原型对象的特殊之处。</p>
<p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat1.color = &apos;black&apos;;</div><div class="line"></div><div class="line">cat2.color // &apos;yellow&apos;</div><div class="line">Animal.prototype.color // &quot;yellow&quot;;</div></pre></td></tr></table></figure></p>
<p>上面代码中，实例对象cat1的color属性改为black，就使得它不再去原型对象读取color属性，后者的值依然为yellow。</p>
<p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的含义，而实例对象可以视作从原型对象衍生出来的子对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Animal.prototype.walk = function () &#123;</div><div class="line">  console.log(this.name + &apos; is walking&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码中，Animal.prototype对象上面定义了一个walk方法，这个方法将可以在所有Animal实例对象上面调用。</p>
<p>由于JavaScript的所有对象都有构造函数，而所有构造函数都有prototype属性（其实是所有函数都有prototype属性），所以所有对象都有自己的原型对象。</p>
<h3 id="1-3原型链"><a href="#1-3原型链" class="headerlink" title="1.3原型链"></a>1.3原型链</h3><p>对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。</p>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。那么，Object.prototype对象有没有它的原型呢？回答可以是有的，就是没有任何属性和方法的null对象，而null对象没有自己的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getPrototypeOf(Object.prototype)</div><div class="line">// null</div></pre></td></tr></table></figure></p>
<p>上面代码表示，Object.prototype对象的原型是null，由于null没有任何属性，所以原型链到此为止。</p>
<p>“原型链”的作用是，读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。</p>
<p>如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overiding）。</p>
<p>需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>
<p>举例来说，如果让某个函数的prototype属性指向一个数组，就意味着该函数可以当作数组的构造函数，因为它生成的实例对象都可以通过prototype属性调用数组方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var MyArray = function () &#123;&#125;;</div><div class="line"></div><div class="line">MyArray.prototype = new Array();</div><div class="line">MyArray.prototype.constructor = MyArray;</div><div class="line"></div><div class="line">var mine = new MyArray();</div><div class="line">mine.push(1, 2, 3);</div><div class="line"></div><div class="line">mine.length // 3</div><div class="line">mine instanceof Array // true</div></pre></td></tr></table></figure></p>
<p>上面代码中，mine是构造函数MyArray的实例对象，由于MyArray的prototype属性指向一个数组实例，使得mine可以调用数组方法（这些方法定义在数组实例的prototype对象上面）。至于最后那行instanceof表达式，我们知道instanceof运算符用来比较一个对象是否为某个构造函数的实例，最后一行就表示mine为Array的实例。</p>
<p>下面的代码可以找出，某个属性到底是原型链上哪个对象自身的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function getDefiningObject(obj, propKey) &#123;</div><div class="line">  while (obj &amp;&amp; !&#123;&#125;.hasOwnProperty.call(obj, propKey)) &#123;</div><div class="line">    obj = Object.getPrototypeOf(obj);</div><div class="line">  &#125;</div><div class="line">  return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="1-4constructor属性"><a href="#1-4constructor属性" class="headerlink" title="1.4constructor属性"></a>1.4constructor属性</h2><p>prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function P() &#123;&#125;</div><div class="line"></div><div class="line">P.prototype.constructor === P</div><div class="line">// true</div></pre></td></tr></table></figure></p>
<p>由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function P() &#123;&#125;</div><div class="line">var p = new P();</div><div class="line"></div><div class="line">p.constructor</div><div class="line">// function P() &#123;&#125;</div><div class="line"></div><div class="line">p.constructor === P.prototype.constructor</div><div class="line">// true</div><div class="line"></div><div class="line">p.hasOwnProperty(&apos;constructor&apos;)</div><div class="line">// false</div></pre></td></tr></table></figure></p>
<p>上面代码中，p是构造函数P的实例对象，但是p自身没有contructor属性，该属性其实是读取原型链上面的P.prototype.constructor属性。</p>
<p>constructor属性的作用，是分辨原型对象到底属于哪个构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function F() &#123;&#125;;</div><div class="line">var f = new F();</div><div class="line"></div><div class="line">f.constructor === F // true</div><div class="line">f.constructor === RegExp // false</div></pre></td></tr></table></figure></p>
<p>上面代码表示，使用constructor属性，确定实例对象f的构造函数是F，而不是RegExp。</p>
<p>有了constructor属性，就可以从实例新建另一个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Constr() &#123;&#125;</div><div class="line">var x = new Constr();</div><div class="line"></div><div class="line">var y = new x.constructor();</div><div class="line">y instanceof Constr // true</div></pre></td></tr></table></figure></p>
<p>上面代码中，x是构造函数Constr的实例，可以从x.constructor间接调用构造函数。</p>
<p>这使得在实例方法中，调用自身的构造函数成为可能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Constr.prototype.createCopy = function () &#123;</div><div class="line">  return new this.constructor();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这也提供了继承模式的一种实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Super() &#123;&#125;</div><div class="line"></div><div class="line">function Sub() &#123;</div><div class="line">  Sub.superclass.constructor.call(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sub.superclass = new Super();</div></pre></td></tr></table></figure></p>
<p>上面代码中，Super和Sub都是构造函数，在Sub内部的this上调用Super，就会形成Sub继承Super的效果。</p>
<p>由于constructor属性是一种原型对象与构造函数的关联关系，所以修改原型对象的时候，务必要小心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">var a = new A();</div><div class="line">a instanceof A // true</div><div class="line"></div><div class="line">function B() &#123;&#125;</div><div class="line">A.prototype = B.prototype;</div><div class="line">a instanceof A // false</div></pre></td></tr></table></figure></p>
<p>上面代码中，a是A的实例。修改了A.prototype以后，constructor属性的指向就变了，导致instanceof运算符失真。</p>
<p>所以，修改原型对象时，一般要同时校正constructor属性的指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 避免这种写法</div><div class="line">C.prototype = &#123;</div><div class="line">  method1: function (...) &#123; ... &#125;,</div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 较好的写法</div><div class="line">C.prototype = &#123;</div><div class="line">  constructor: C,</div><div class="line">  method1: function (...) &#123; ... &#125;,</div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 好的写法</div><div class="line">C.prototype.method1 = function (...) &#123; ... &#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码中，避免完全覆盖掉原来的prototype属性，要么将constructor属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证instanceof运算符不会失真。</p>
<p>此外，通过name属性，可以从实例得到构造函数的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123;&#125;</div><div class="line">var f = new Foo();</div><div class="line">f.constructor.name // &quot;Foo&quot;</div></pre></td></tr></table></figure></p>
<h2 id="2-instanceof运算符"><a href="#2-instanceof运算符" class="headerlink" title="2.instanceof运算符"></a>2.instanceof运算符</h2><p>instanceof运算符返回一个布尔值，表示指定对象是否为某个构造函数的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var v = new Vehicle();</div><div class="line">v instanceof Vehicle // true</div></pre></td></tr></table></figure></p>
<p>上面代码中，对象v是构造函数Vehicle的实例，所以返回true。</p>
<p>instanceof运算符的左边是实例对象，右边是构造函数。它的运算实质是检查右边构建函数的原型对象，是否在左边对象的原型链上。因此，下面两种写法是等价的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">v instanceof Vehicle</div><div class="line">// 等同于</div><div class="line">Vehicle.prototype.isPrototypeOf(v)</div></pre></td></tr></table></figure></p>
<p>由于instanceof对整个原型链上的对象都有效，因此同一个实例对象，可能会对多个构造函数都返回true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var d = new Date();</div><div class="line">d instanceof Date // true</div><div class="line">d instanceof Object // true</div></pre></td></tr></table></figure></p>
<p>上面代码中，d同时是Date和Object的实例，因此对这两个构造函数都返回true。</p>
<p>instanceof的原理是检查原型链，对于那些不存在原型链的对象，就无法判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.create(null) instanceof Object // false</div></pre></td></tr></table></figure></p>
<p>上面代码中，Object.create(null)返回的新对象的原型是null，即不存在原型，因此instanceof就认为该对象不是Object的实例。</p>
<p>除了上面这种继承null的特殊情况，JavaScript之中，只要是对象，就有对应的构造函数。因此，instanceof运算符的一个用处，是判断值的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var x = [1, 2, 3];</div><div class="line">var y = &#123;&#125;;</div><div class="line">x instanceof Array // true</div><div class="line">y instanceof Object // true</div></pre></td></tr></table></figure></p>
<p>上面代码中，instanceof运算符判断，变量x是数组，变量y是对象。</p>
<p>注意，instanceof运算符只能用于对象，不适用原始类型的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var s = &apos;hello&apos;;</div><div class="line">s instanceof String // false</div></pre></td></tr></table></figure></p>
<p>上面代码中，字符串不是String对象的实例（因为字符串不是对象），所以返回false。</p>
<p>此外，undefined和null不是对象，所以instanceOf运算符总是返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">undefined instanceof Object // false</div><div class="line">null instanceof Object // false</div></pre></td></tr></table></figure></p>
<p>利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Fubar (foo, bar) &#123;</div><div class="line">  if (this instanceof Fubar) &#123;</div><div class="line">    this._foo = foo;</div><div class="line">    this._bar = bar;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    return new Fubar(foo, bar);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码使用instanceof运算符，在函数体内部判断this关键字是否为构造函数Fubar的实例。如果不是，就表明忘了加new命令。</p>
<h2 id="3-Object-getPrototypeOf"><a href="#3-Object-getPrototypeOf" class="headerlink" title="3.Object.getPrototypeOf()"></a>3.Object.getPrototypeOf()</h2><p>Object.getPrototypeOf方法返回一个对象的原型。这是获取原型对象的标准方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 空对象的原型是Object.prototype</div><div class="line">Object.getPrototypeOf(&#123;&#125;) === Object.prototype</div><div class="line">// true</div><div class="line"></div><div class="line">// 函数的原型是Function.prototype</div><div class="line">function f() &#123;&#125;</div><div class="line">Object.getPrototypeOf(f) === Function.prototype</div><div class="line">// true</div><div class="line"></div><div class="line">// f 为 F 的实例对象，则 f 的原型是 F.prototype</div><div class="line">var f = new F();</div><div class="line">Object.getPrototypeOf(f) === F.prototype</div><div class="line">// true</div></pre></td></tr></table></figure></p>
<h2 id="4-Object-setPrototypeOf"><a href="#4-Object-setPrototypeOf" class="headerlink" title="4.Object.setPrototypeOf()"></a>4.Object.setPrototypeOf()</h2><p>Object.setPrototypeOf方法可以为现有对象设置原型，返回一个新对象。</p>
<p>Object.setPrototypeOf方法接受两个参数，第一个是现有对象，第二个是原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = &#123;x: 1&#125;;</div><div class="line">var b = Object.setPrototypeOf(&#123;&#125;, a);</div><div class="line">// 等同于</div><div class="line">// var b = &#123;__proto__: a&#125;;</div><div class="line"></div><div class="line">b.x // 1</div></pre></td></tr></table></figure></p>
<p>上面代码中，b对象是Object.setPrototypeOf方法返回的一个新对象。该对象本身为空、原型为a对象，所以b对象可以拿到a对象的所有属性和方法。b对象本身并没有x属性，但是JavaScript引擎找到它的原型对象a，然后读取a的x属性。</p>
<p>new命令通过构造函数新建实例对象，实质就是将实例对象的原型，指向构造函数的prototype属性，然后在实例对象上执行构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var F = function () &#123;</div><div class="line">  this.foo = &apos;bar&apos;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var f = new F();</div><div class="line"></div><div class="line">// 等同于</div><div class="line">var f = Object.setPrototypeOf(&#123;&#125;, F.prototype);</div><div class="line">F.call(f);</div></pre></td></tr></table></figure></p>
<h2 id="5-Object-create"><a href="#5-Object-create" class="headerlink" title="5.Object.create()"></a>5.Object.create()</h2><p>Object.create方法用于从原型对象生成新的实例对象，可以替代new命令。</p>
<p>它接受一个对象作为参数，返回一个新对象，后者完全继承前者的属性，即原有对象成为新对象的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var A = &#123;</div><div class="line"> print: function () &#123;</div><div class="line">   console.log(&apos;hello&apos;);</div><div class="line"> &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var B = Object.create(A);</div><div class="line"></div><div class="line">B.print() // hello</div><div class="line">B.print === A.print // true</div></pre></td></tr></table></figure></p>
<p>上面代码中，Object.create方法在A的基础上生成了B。此时，A就成了B的原型，B就继承了A的所有属性和方法。这段代码等同于下面的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var A = function () &#123;&#125;;</div><div class="line">A.prototype = &#123;</div><div class="line"> print: function () &#123;</div><div class="line">   console.log(&apos;hello&apos;);</div><div class="line"> &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var B = new A();</div><div class="line"></div><div class="line">B.print === A.prototype.print // true</div></pre></td></tr></table></figure></p>
<p>实际上，Object.create方法可以用下面的代码代替。如果老式浏览器不支持Object.create方法，可以就用这段代码自己部署。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (typeof Object.create !== &apos;function&apos;) &#123;</div><div class="line">  Object.create = function (o) &#123;</div><div class="line">    function F() &#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    return new F();</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码表示，Object.create方法实质是新建一个构造函数F，然后让F的prototype属性指向作为原型的对象o，最后返回一个F的实例，从而实现让实例继承o的属性。</p>
<p>下面三种方式生成的新对象是等价的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var o1 = Object.create(&#123;&#125;);</div><div class="line">var o2 = Object.create(Object.prototype);</div><div class="line">var o3 = new Object();</div></pre></td></tr></table></figure></p>
<p>如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = Object.create(null);</div><div class="line"></div><div class="line">o.valueOf()</div><div class="line">// TypeError: Object [object Object] has no method &apos;valueOf&apos;</div></pre></td></tr></table></figure></p>
<p>上面代码表示，如果对象o的原型是null，它就不具备一些定义在Object.prototype对象上面的属性，比如valueOf方法。</p>
<p>使用Object.create方法的时候，必须提供对象原型，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.create()</div><div class="line">// TypeError: Object prototype may only be an Object or null</div></pre></td></tr></table></figure></p>
<p>object.create方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123; p: 1 &#125;;</div><div class="line">var o2 = Object.create(o1);</div><div class="line"></div><div class="line">o1.p = 2;</div><div class="line">o2.p</div><div class="line">// 2</div></pre></td></tr></table></figure></p>
<p>上面代码表示，修改对象原型会影响到新生成的对象。</p>
<p>除了对象的原型，Object.create方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到新对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var o = Object.create(&#123;&#125;, &#123;</div><div class="line">  p1: &#123; value: 123, enumerable: true &#125;,</div><div class="line">  p2: &#123; value: &apos;abc&apos;, enumerable: true &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 等同于</div><div class="line">var o = Object.create(&#123;&#125;);</div><div class="line">o.p1 = 123;</div><div class="line">o.p2 = &apos;abc&apos;;</div></pre></td></tr></table></figure></p>
<p>Object.create方法生成的对象，继承了它的原型对象的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">var a = new A();</div><div class="line">var b = Object.create(a);</div><div class="line"></div><div class="line">b.constructor === A // true</div><div class="line">b instanceof A // true</div></pre></td></tr></table></figure></p>
<p>上面代码中，b对象的原型是a对象，因此继承了a对象的构造函数A。</p>
<h2 id="6-Object-prototype-isPrototypeOf"><a href="#6-Object-prototype-isPrototypeOf" class="headerlink" title="6.Object.prototype.isPrototypeOf()"></a>6.Object.prototype.isPrototypeOf()</h2><p>对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123;&#125;;</div><div class="line">var o2 = Object.create(o1);</div><div class="line">var o3 = Object.create(o2);</div><div class="line"></div><div class="line">o2.isPrototypeOf(o3) // true</div><div class="line">o1.isPrototypeOf(o3) // true</div></pre></td></tr></table></figure></p>
<p>上面代码表明，只要某个对象处在原型链上，isPrototypeOf都返回true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object.prototype.isPrototypeOf(&#123;&#125;) // true</div><div class="line">Object.prototype.isPrototypeOf([]) // true</div><div class="line">Object.prototype.isPrototypeOf(/xyz/) // true</div><div class="line">Object.prototype.isPrototypeOf(Object.create(null)) // false</div></pre></td></tr></table></figure></p>
<p>上面代码中，由于Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有继承null的对象除外。</p>
<h2 id="7-Object-prototype-proto"><a href="#7-Object-prototype-proto" class="headerlink" title="7.Object.prototype.proto"></a>7.Object.prototype.<strong>proto</strong></h2><p><strong>proto</strong>属性（前后各两个下划线）可以改写某个对象的原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">var p = &#123;&#125;;</div><div class="line"></div><div class="line">obj.__proto__ = p;</div><div class="line">Object.getPrototypeOf(obj) === p // true</div></pre></td></tr></table></figure></p>
<p>上面代码通过<strong>proto</strong>属性，将p对象设为obj对象的原型。</p>
<p>根据语言标准，<strong>proto</strong>属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()（读取）和Object.setPrototypeOf()（设置），进行原型对象的读写操作。</p>
<p>原型链可以用<strong>proto</strong>很直观地表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var A = &#123;</div><div class="line">  name: &apos;张三&apos;</div><div class="line">&#125;;</div><div class="line">var B = &#123;</div><div class="line">  name: &apos;李四&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var proto = &#123;</div><div class="line">  print: function () &#123;</div><div class="line">    console.log(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A.__proto__ = proto;</div><div class="line">B.__proto__ = proto;</div><div class="line"></div><div class="line">A.print() // 张三</div><div class="line">B.print() // 李四</div></pre></td></tr></table></figure></p>
<p>上面代码中，A对象和B对象的原型都是proto对象，它们都共享proto对象的print方法。也就是说，A和B的print方法，都是在调用proto对象的print方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A.print === B.print // true</div><div class="line">A.print === proto.print // true</div><div class="line">B.print === proto.print // true</div></pre></td></tr></table></figure></p>
<p>可以使用Object.getPrototypeOf方法，检查浏览器是否支持<strong>proto</strong>属性，老式浏览器不支持这个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.getPrototypeOf(&#123; __proto__: null &#125;) === null</div></pre></td></tr></table></figure></p>
<p>上面代码将一个对象的<strong>proto</strong>属性设为null，然后使用Object.getPrototypeOf方法获取这个对象的原型，判断是否等于null。如果当前环境支持<strong>proto</strong>属性，两者的比较结果应该是true。</p>
<h2 id="8-获取原型对象方法的比较"><a href="#8-获取原型对象方法的比较" class="headerlink" title="8.获取原型对象方法的比较"></a>8.获取原型对象方法的比较</h2><p>如前所述，<strong>proto</strong>属性指向当前对象的原型对象，即构造函数的prototype属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var obj = new Object();</div><div class="line"></div><div class="line">obj.__proto__ === Object.prototype</div><div class="line">// true</div><div class="line">obj.__proto__ === obj.constructor.prototype</div><div class="line">// true</div></pre></td></tr></table></figure></p>
<p>上面代码首先新建了一个对象obj，它的<strong>proto</strong>属性，指向构造函数（Object或obj.constructor）的prototype属性。所以，两者比较以后，返回true。</p>
<p>因此，获取实例对象obj的原型对象，有三种方法。</p>
<ul>
<li>obj.<strong>proto</strong></li>
<li>obj.constructor.prototype</li>
<li>Object.getPrototypeOf(obj)<br>上面三种方法之中，前两种都不是很可靠。最新的ES6标准规定，<strong>proto</strong>属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var P = function () &#123;&#125;;</div><div class="line">var p = new P();</div><div class="line"></div><div class="line">var C = function () &#123;&#125;;</div><div class="line">C.prototype = p;</div><div class="line">var c = new C();</div><div class="line"></div><div class="line">c.constructor.prototype === p // false</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，C构造函数的原型对象被改成了p，结果c.constructor.prototype就失真了。所以，在改变原型对象时，一般要同时设置constructor属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C.prototype = p;</div><div class="line">C.prototype.constructor = C;</div><div class="line"></div><div class="line">c.constructor.prototype === p // true</div></pre></td></tr></table></figure></p>
<p>所以，推荐使用第三种Object.getPrototypeOf方法，获取原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div><div class="line">Object.getPrototypeOf(o) === Object.prototype</div><div class="line">// true</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/07/面向对象编程-prototype-对象/" data-id="cizy67m0d0004ocuwcjueuc15" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面向对象编程/">-面向对象编程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/10/06/面向对象编程-this-关键字/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">面向对象编程-this 关键字</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/">-css3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/">-html5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面向对象编程/">-面向对象编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/css3/" style="font-size: 10px;">-css3</a> <a href="/tags/html5/" style="font-size: 10px;">-html5</a> <a href="/tags/面向对象编程/" style="font-size: 20px;">-面向对象编程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/10/07/面向对象编程-prototype-对象/">面向对象编程-prototype 对象</a>
          </li>
        
          <li>
            <a href="/2015/10/06/面向对象编程-this-关键字/">面向对象编程-this 关键字</a>
          </li>
        
          <li>
            <a href="/2015/10/03/面向对象编程-面向对象编程的模式/">面向对象编程-面向对象编程的模式</a>
          </li>
        
          <li>
            <a href="/2015/10/02/面向对象编程-Object-对象与继承/">面向对象编程-Object 对象与继承</a>
          </li>
        
          <li>
            <a href="/2015/10/01/面向对象编程-构造函数与-new-命令/">面向对象编程-构造函数与 new 命令</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 xxh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>